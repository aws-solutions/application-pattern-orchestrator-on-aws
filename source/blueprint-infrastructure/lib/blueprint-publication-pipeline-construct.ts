/* 
  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
  
  Licensed under the Apache License, Version 2.0 (the "License").
  You may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  
      http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/* eslint-disable @typescript-eslint/naming-convention */
import { Construct } from 'constructs';
import { ISecurityGroup, IVpc, SubnetType } from 'aws-cdk-lib/aws-ec2';
import * as path from 'path';
import { generateReleaseStageBuildspec } from './buildspecs';
import { Artifact, IAction, Pipeline } from 'aws-cdk-lib/aws-codepipeline';
import {
    AccountPrincipal,
    AnyPrincipal,
    Effect,
    PolicyStatement,
    Role,
} from 'aws-cdk-lib/aws-iam';
import { BlockPublicAccess, Bucket, BucketEncryption } from 'aws-cdk-lib/aws-s3';
import {
    CodeBuildAction,
    CodeCommitSourceAction,
    CodeStarConnectionsSourceAction,
    LambdaInvokeAction,
    S3DeployAction,
    S3SourceAction,
    S3Trigger,
} from 'aws-cdk-lib/aws-codepipeline-actions';
import {
    BuildEnvironmentVariable,
    BuildSpec,
    LinuxBuildImage,
    Project,
} from 'aws-cdk-lib/aws-codebuild';
import {
    Aws,
    Aspects,
    aws_lambda_nodejs,
    Duration,
    PhysicalName,
    RemovalPolicy,
    Fn,
} from 'aws-cdk-lib';
import { Runtime } from 'aws-cdk-lib/aws-lambda';
import { IKey, Key, Alias } from 'aws-cdk-lib/aws-kms';
import {
    BlueprintType,
    GithubConfigPatternPublishPipeline,
    CodeCommitPipelineConfig,
} from './blueprint-infrastructure-types';
import {
    addCfnNagSuppression,
    CfnNagResourcePathEndingWithSuppressionAspect,
} from './cfn-nag-suppression';

export interface BlueprintPublicationPipelineConstructProps {
    vpc: IVpc;
    securityGroup: ISecurityGroup;
    blueprintId: string;
    blueprintType: BlueprintType;
    releaseBranchName: string;
    repositoryName: string;
    repositoryMainBranchName: string;
    githubConfig?: GithubConfigPatternPublishPipeline;
    codeCommitPipelineConfig?: CodeCommitPipelineConfig;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    buildSpec: any;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sharedConfig: any;
}

export class BlueprintPublicationPipelineConstruct extends Construct {
    /**
     * Create the CodePipeline that publishes new versions of a blueprint
     * @param scope
     * @param id
     * @param props
     */
    public constructor(
        scope: Construct,
        id: string,
        props: BlueprintPublicationPipelineConstructProps
    ) {
        super(scope, id);

        const { s3Bucket: pipelineArtifactsBucket } = this.createPipelineArtifactBucket(
            props.blueprintId,
            props.blueprintType,
            props.sharedConfig.s3BucketEncryptionKeyARN
        );

        const blueprintPortalUrl = Fn.importValue('rapmExportedPortalUrl');

        const pipeline = new Pipeline(this, 'BlueprintPublicationPipeline', {
            pipelineName: `BlueprintPublicationPipeline_${props.blueprintId}`,
            artifactBucket: pipelineArtifactsBucket,
            // Restart pipeline when the UpdateStage updates the pipeline definition
            restartExecutionOnUpdate: true,
        });
        addCfnNagSuppression(
            pipeline.role,
            [
                {
                    id: 'W12',
                    reason: 'The policy is automatically generated by CDK.',
                },
                {
                    id: 'W76',
                    reason: 'The policy is automatically generated by CDK.',
                },
            ],
            'DefaultPolicy'
        );
        Aspects.of(pipeline).add(
            new CfnNagResourcePathEndingWithSuppressionAspect(
                '/PolicyDocument/Resource',
                [
                    {
                        id: 'W12',
                        reason: 'The policy is automatically generated by CDK.',
                    },
                    {
                        id: 'W76',
                        reason: 'The policy is automatically generated by CDK.',
                    },
                ]
            )
        );

        pipelineArtifactsBucket.grantReadWrite(pipeline.role);
        pipeline.addToRolePolicy(
            new PolicyStatement({
                effect: Effect.ALLOW,
                actions: [
                    'codestar-connections:UseConnection',
                    'appconfig:StartDeployment',
                    'appconfig:GetDeployment',
                    'appconfig:StopDeployment',
                    'codecommit:GetRepository',
                ],
                resources: [`*`],
            })
        );

        const sourceVariablesNamespace = 'SourceVariables';
        const sourceOutput = new Artifact();
        const blueprintInfrastructureOutput = new Artifact();

        // Bucket where the CDK stack defining blueprint infrastructure definition is stored
        // This is used to refresh the blueprint infrastructure definition everytime the pipeline runs
        const blueprintInfrastructureBucket = Bucket.fromBucketName(
            this,
            'BlueprintInfrastructureBucket',
            props.sharedConfig.blueprintInfrastructureBucketName
        );

        const sourceStageActions: IAction[] = [
            new S3SourceAction({
                actionName: 'Pattern_Infrastructure_Source',
                output: blueprintInfrastructureOutput,
                bucket: blueprintInfrastructureBucket,
                // Do not automatically trigger the pipeline when the blueprint infrastructure definition changes
                trigger: S3Trigger.NONE,
                bucketKey: props.sharedConfig.blueprintInfrastructureArchiveName,
            }),
        ];

        if (props.githubConfig) {
            sourceStageActions.unshift(
                new CodeStarConnectionsSourceAction({
                    actionName: `GitHub_Source`,
                    owner: props.githubConfig.githubOrganization,
                    repo: props.repositoryName,
                    connectionArn: props.githubConfig.githubConnectionArn,
                    output: sourceOutput,
                    branch: props.repositoryMainBranchName,
                    variablesNamespace: sourceVariablesNamespace,
                    // Cloning the output allows to use semantic-release from codepipeline
                    codeBuildCloneOutput: true,
                })
            );
        } else if (props.codeCommitPipelineConfig) {
            sourceStageActions.unshift(
                new CodeCommitSourceAction({
                    actionName: `CodeCommit_Source`,
                    repository: props.codeCommitPipelineConfig.patternRepository,
                    output: sourceOutput,
                    branch: props.repositoryMainBranchName,
                    variablesNamespace: sourceVariablesNamespace,
                    codeBuildCloneOutput: true,
                })
            );
        } else {
            throw new Error(
                'Neither GitHub nor CodeCommit config passed to pattern pipeline construct'
            );
        }

        pipeline.addStage({
            stageName: 'Source',
            actions: sourceStageActions,
        });

        // Re-use the update blueprint infrastructure project for the update stage
        const updateBlueprintInfrastructureProject = Project.fromProjectName(
            this,
            'UpdateBlueprintInfrastructureProject',
            props.sharedConfig.updateBlueprintInfrastructureProjectName
        );

        const updatePipelineActionEnvVars: Record<string, BuildEnvironmentVariable> = {
            BLUEPRINT_ID: { value: props.blueprintId },
            BLUEPRINT_TYPE: { value: props.blueprintType },
            REPOSITORY_NAME: {
                value: props.repositoryName,
            },
            REPOSITORY_MAIN_BRANCH_NAME: {
                value: props.repositoryMainBranchName,
            },
        };
        if (props.githubConfig) {
            updatePipelineActionEnvVars['GITHUB_REPOSITORY_OWNER'] = {
                value: props.githubConfig.githubOrganization,
            };
        }
        pipeline.addStage({
            stageName: 'UpdatePipeline',
            actions: [
                new CodeBuildAction({
                    actionName: 'Update_Pattern_Infrastructure',
                    input: blueprintInfrastructureOutput,
                    project: updateBlueprintInfrastructureProject,
                    environmentVariables: updatePipelineActionEnvVars,
                }),
            ],
        });

        const templatesOutput = new Artifact('templates');
        const controlsOutput = new Artifact('controls');
        const imagesOutput = new Artifact('images');
        const markdownOutput = new Artifact('markdown');

        const buildAction = new CodeBuildAction({
            actionName: 'Build_Pattern',
            input: sourceOutput,
            outputs: [templatesOutput, controlsOutput, imagesOutput, markdownOutput],
            project: new Project(this, 'Build', {
                environment: {
                    buildImage: LinuxBuildImage.STANDARD_7_0,
                },
                buildSpec: BuildSpec.fromObject(props.buildSpec),
                vpc: props.vpc,
                subnetSelection: {
                    subnetType: SubnetType.PRIVATE_WITH_EGRESS,
                },
            }),
        });

        pipeline.addStage({
            stageName: 'Build',
            actions: [buildAction],
        });

        const artifactsBaseLocation = `${props.blueprintId}/#{${sourceVariablesNamespace}.CommitId}`;
        const templatesArtifactsLocation = `${artifactsBaseLocation}/templates`;
        const controlArtifactsLocation = `${artifactsBaseLocation}/controls`;
        const imageArtifactsLocation = `${artifactsBaseLocation}/images`;
        const markdownArtifactsLocation = `${artifactsBaseLocation}/markdown`;

        const artifactsBucket = Bucket.fromBucketName(
            this,
            'BlueprintBuildArtifactsBucket',
            props.sharedConfig.blueprintArtifactsBucketName
        );

        const storeArtifactsRole = new Role(this, 'StoreArtifactsRole', {
            assumedBy: new AccountPrincipal(Aws.ACCOUNT_ID),
        });

        // Give permission to store artifacts in the blueprint artifacts bucket
        storeArtifactsRole.addToPolicy(
            new PolicyStatement({
                effect: Effect.ALLOW,
                actions: ['kms:Decrypt', 'kms:GenerateDataKey*'],
                resources: [
                    `${props.sharedConfig.blueprintArtifactsBucketEncryptionKeyArn}`,
                ],
            })
        );

        pipeline.addStage({
            stageName: 'StoreArtifacts',
            actions: [
                new S3DeployAction({
                    actionName: 'Store_Templates_Artifacts',
                    bucket: artifactsBucket,
                    objectKey: templatesArtifactsLocation,
                    extract: true,
                    input: templatesOutput,
                    role: storeArtifactsRole,
                }),
                new S3DeployAction({
                    actionName: 'Store_Control_Artifacts',
                    bucket: artifactsBucket,
                    objectKey: controlArtifactsLocation,
                    extract: true,
                    input: controlsOutput,
                    role: storeArtifactsRole,
                }),
                new S3DeployAction({
                    actionName: 'Store_Image_Artifacts',
                    bucket: artifactsBucket,
                    objectKey: imageArtifactsLocation,
                    extract: true,
                    input: imagesOutput,
                    role: storeArtifactsRole,
                }),
                new S3DeployAction({
                    actionName: 'Store_Markdown_Artifacts',
                    bucket: artifactsBucket,
                    objectKey: markdownArtifactsLocation,
                    extract: true,
                    input: markdownOutput,
                    role: storeArtifactsRole,
                }),
            ],
        });

        const releaseBuildSpec = generateReleaseStageBuildspec(
            props.blueprintType,
            props.sharedConfig.proxyUri
        );

        const releaseProject = new Project(this, 'Release', {
            environment: {
                buildImage: LinuxBuildImage.STANDARD_7_0,
                environmentVariables: {
                    RELEASE_BRANCH_NAME: {
                        value: props.releaseBranchName,
                    },
                    CODEARTIFACT_DOMAIN_NAME: {
                        value: props.sharedConfig.codeArtifactDomainName || '',
                    },
                    CODEARTIFACT_REPOSITORY_NAME: {
                        value: props.sharedConfig.codeArtifactRepositoryName || '',
                    },
                },
            },
            buildSpec: BuildSpec.fromObject(releaseBuildSpec),
            vpc: props.vpc,
            subnetSelection: {
                subnetType: SubnetType.PRIVATE_WITH_EGRESS,
            },
        });
        // permissions for CodeCommit pattern repo
        if (!props.githubConfig) {
            releaseProject.addToRolePolicy(
                new PolicyStatement({
                    effect: Effect.ALLOW,
                    actions: [
                        'codecommit:GetRepository',
                        'codecommit:CreateBranch',
                        'codecommit:CreateUnreferencedMergeCommit',
                        'codecommit:PutFile',
                        'codecommit:CreateCommit',
                        'codecommit:GitPush',
                    ],
                    resources: [
                        `arn:aws:codecommit:${Aws.REGION}:${Aws.ACCOUNT_ID}:${props.repositoryName}`,
                    ],
                })
            );
        }

        // Add permission to login and publish to the blueprint code artifact repository for CDK blueprint release
        if (
            props.blueprintType === 'CDK' &&
            props.sharedConfig.codeArtifactDomainName &&
            props.sharedConfig.codeArtifactRepositoryName
        ) {
            releaseProject.addToRolePolicy(
                new PolicyStatement({
                    effect: Effect.ALLOW,
                    actions: ['codeartifact:GetAuthorizationToken'],
                    resources: [
                        `arn:aws:codeartifact:${Aws.REGION}:${Aws.ACCOUNT_ID}:domain/${props.sharedConfig.codeArtifactDomainName}`,
                    ],
                })
            );
            releaseProject.addToRolePolicy(
                new PolicyStatement({
                    effect: Effect.ALLOW,
                    actions: ['codeartifact:GetRepositoryEndpoint'],
                    resources: [
                        `arn:aws:codeartifact:${Aws.REGION}:${Aws.ACCOUNT_ID}:repository/${props.sharedConfig.codeArtifactDomainName}/${props.sharedConfig.codeArtifactRepositoryName}`,
                    ],
                })
            );
            releaseProject.addToRolePolicy(
                new PolicyStatement({
                    effect: Effect.ALLOW,
                    actions: ['codeartifact:PublishPackageVersion'],
                    resources: [
                        `arn:aws:codeartifact:${Aws.REGION}:${Aws.ACCOUNT_ID}:package/${props.sharedConfig.codeArtifactDomainName}/${props.sharedConfig.codeArtifactRepositoryName}*`,
                    ],
                })
            );
            releaseProject.addToRolePolicy(
                new PolicyStatement({
                    effect: Effect.ALLOW,
                    actions: ['sts:GetServiceBearerToken'],
                    resources: ['*'],
                    conditions: {
                        StringEquals: {
                            'sts:AWSServiceName': 'codeartifact.amazonaws.com',
                        },
                    },
                })
            );
        }

        const releaseAction = new CodeBuildAction({
            actionName: 'Release_Pattern',
            input: sourceOutput,
            project: releaseProject,
        });

        pipeline.addStage({
            stageName: 'Release',
            actions: [releaseAction],
        });

        let publishAction;
        // CFN blueprints have a publich stage to publish templates to service catalog
        if (props.blueprintType === 'CFN') {
            const publishBlueprintToServiceCatalogLambda =
                new aws_lambda_nodejs.NodejsFunction(
                    this,
                    'PublishBlueprintToServiceCatalogLambda',
                    {
                        runtime: Runtime.NODEJS_18_X,
                        handler: 'handler',
                        entry: path.join(
                            __dirname,
                            '../lambda/codepipeline/blueprint/publish.ts'
                        ),
                        timeout: Duration.seconds(30),
                        environment: {
                            BLUEPRINT_ID: props.blueprintId,
                            BLUEPRINT_ARTIFACTS_BUCKET_NAME:
                                props.sharedConfig.blueprintArtifactsBucketName,
                            AWS_ACCOUNT: Aws.ACCOUNT_ID,
                            BLUEPRINT_SERVICE_CATALOG_PORTFOLIO_ID:
                                props.sharedConfig.blueprintServiceCatalogPortfolioId,
                            RAPM_METADATA_TABLE_NAME:
                                props.sharedConfig.rapmMetaDataTable,
                            SOLUTION_USER_AGENT: props.sharedConfig.customUserAgent,
                            LOG_LEVEL: props.sharedConfig.logLevel,
                        },
                        vpc: props.vpc,
                        vpcSubnets: {
                            subnetType: SubnetType.PRIVATE_WITH_EGRESS,
                        },
                        securityGroups: [props.securityGroup],
                    }
                );

            // Service catalog permissions
            publishBlueprintToServiceCatalogLambda.addToRolePolicy(
                new PolicyStatement({
                    effect: Effect.ALLOW,
                    actions: [
                        'servicecatalog:DescribeProductAsAdmin',
                        'servicecatalog:CreateProduct',
                        'servicecatalog:CreateProvisioningArtifact',
                        'servicecatalog:AssociateProductWithPortfolio',
                    ],
                    // Product names are automatically generated so we can't scope the resources down
                    resources: ['*'],
                })
            );

            // permission to get pattern from DynamoDb
            publishBlueprintToServiceCatalogLambda.addToRolePolicy(
                new PolicyStatement({
                    effect: Effect.ALLOW,
                    actions: ['dynamodb:GetItem'],
                    resources: [
                        `arn:aws:dynamodb:${Aws.REGION}:${Aws.ACCOUNT_ID}:table/${props.sharedConfig.rapmMetaDataTable}`,
                    ],
                })
            );

            // Permission required to validate CFN templates before creating a provisioning artifact
            publishBlueprintToServiceCatalogLambda.addToRolePolicy(
                new PolicyStatement({
                    effect: Effect.ALLOW,
                    actions: ['cloudformation:ValidateTemplate'],
                    resources: ['*'],
                })
            );

            artifactsBucket.grantReadWrite(publishBlueprintToServiceCatalogLambda);

            publishBlueprintToServiceCatalogLambda.addToRolePolicy(
                new PolicyStatement({
                    effect: Effect.ALLOW,
                    actions: [
                        'kms:Decrypt',
                        'kms:List*',
                        'kms:DescribeKey',
                        'kms:GenerateDataKey',
                    ],
                    resources: [
                        `${props.sharedConfig.blueprintArtifactsBucketEncryptionKeyArn}`,
                    ],
                })
            );
            publishBlueprintToServiceCatalogLambda.addToRolePolicy(
                new PolicyStatement({
                    effect: Effect.ALLOW,
                    actions: ['kms:Decrypt', 'kms:List*', 'kms:DescribeKey'],
                    resources: [`${props.sharedConfig.rapmMetaDataTableEncryptionKey}`],
                })
            );

            publishAction = new LambdaInvokeAction({
                actionName: 'Publish_Pattern_To_Service_Catalog',
                lambda: publishBlueprintToServiceCatalogLambda,
                userParameters: {
                    CHANGED_PACKAGES: releaseAction.variable('CHANGED_PACKAGES'),
                    ALL_PACKAGES: releaseAction.variable('ALL_PACKAGES'),
                    TEMPLATES_ARTIFACTS_LOCATION: templatesArtifactsLocation,
                },
            });

            pipeline.addStage({
                stageName: 'Publish',
                actions: [publishAction],
            });
        }

        const registerBlueprintLambda = new aws_lambda_nodejs.NodejsFunction(
            this,
            'RegisterBlueprintLambda',
            {
                runtime: Runtime.NODEJS_18_X,
                handler: 'handler',
                entry: path.join(
                    __dirname,
                    '../lambda/codepipeline/blueprint/register.ts'
                ),
                bundling: {
                    externalModules: ['@aws-sdk/signature-v4-crt'],
                },
                timeout: Duration.seconds(30),
                environment: {
                    BLUEPRINT_ID: props.blueprintId,
                    RAPM_METADATA_TABLE_NAME: props.sharedConfig.rapmMetaDataTable,
                    RAPM_PUBLISH_DATA_TABLE_NAME: props.sharedConfig.rapmPublishDataTable,
                    AWS_ACCOUNT: Aws.ACCOUNT_ID,
                    CODE_ARTIFACT_DOMAIN_NAME:
                        props.sharedConfig.codeArtifactDomainName || '',
                    CODE_ARTIFACT_REPOSITORY_NAME:
                        props.sharedConfig.codeArtifactRepositoryName || '',
                    BLUEPRINT_ARTIFACTS_BUCKET_NAME:
                        props.sharedConfig.blueprintArtifactsBucketName,
                    RAPM_NOTIFICATION_TOPIC_ARN:
                        props.sharedConfig.blueprintGovernanceNotificationTopicArn,
                    SOLUTION_USER_AGENT: props.sharedConfig.customUserAgent,
                    SOLUTION_NAME: props.sharedConfig.solutionName,
                    SOLUTION_TRADEMARK_NAME: props.sharedConfig.solutionTradeMarkName,
                    RAPM_PORTAL_URL: blueprintPortalUrl,
                    LOG_LEVEL: props.sharedConfig.logLevel,
                },
                vpc: props.vpc,
                vpcSubnets: {
                    subnetType: SubnetType.PRIVATE_WITH_EGRESS,
                },
                securityGroups: [props.securityGroup],
            }
        );

        registerBlueprintLambda.addToRolePolicy(
            new PolicyStatement({
                effect: Effect.ALLOW,
                actions: ['dynamodb:PutItem', 'dynamodb:UpdateItem'],
                resources: [
                    `arn:aws:dynamodb:${Aws.REGION}:${Aws.ACCOUNT_ID}:table/${props.sharedConfig.rapmMetaDataTable}`,
                    `arn:aws:dynamodb:${Aws.REGION}:${Aws.ACCOUNT_ID}:table/${props.sharedConfig.rapmPublishDataTable}`,
                ],
            })
        );
        registerBlueprintLambda.addToRolePolicy(
            new PolicyStatement({
                effect: Effect.ALLOW,
                actions: ['dynamodb:GetItem'],
                resources: [
                    `arn:aws:dynamodb:${Aws.REGION}:${Aws.ACCOUNT_ID}:table/${props.sharedConfig.rapmMetaDataTable}`,
                ],
            })
        );
        registerBlueprintLambda.addToRolePolicy(
            new PolicyStatement({
                effect: Effect.ALLOW,
                actions: ['sns:Publish'],
                resources: [
                    `${props.sharedConfig.blueprintGovernanceNotificationTopicArn}`,
                ],
            })
        );
        registerBlueprintLambda.addToRolePolicy(
            new PolicyStatement({
                effect: Effect.ALLOW,
                actions: ['kms:Decrypt', 'kms:GenerateDataKey*'],
                resources: [`${props.sharedConfig.blueprintSnsEncryptionKeyArn}`],
            })
        );
        addCfnNagSuppression(registerBlueprintLambda, [
            {
                id: 'W58',
                reason: 'The permission to write to CloudWatch Logs already exists',
            },
            {
                id: 'W92',
                reason: 'Some new AWS accounts have very low limit for concurrency causing deployment to fail',
            },
        ]);

        const kmsKeys = [];
        if (props.sharedConfig.blueprintArtifactsBucketEncryptionKeyArn) {
            // Give permission to blueprint artifacts bucket encryption key
            kmsKeys.push(props.sharedConfig.blueprintArtifactsBucketEncryptionKeyArn);
        }
        if (props.sharedConfig.rapmMetaDataTableEncryptionKey) {
            // Give permission to rapm metadata table encryption key
            kmsKeys.push(props.sharedConfig.rapmMetaDataTableEncryptionKey);
        }
        if (props.sharedConfig.rapmPublishDataTableEncryptionKey) {
            // Give permission to rapm publish data table encryption key
            kmsKeys.push(props.sharedConfig.rapmPublishDataTableEncryptionKey);
        }
        if (props.sharedConfig.rapmAttributesTableEncryptionKey) {
            // Give permission to rapm attributes table encryption key
            kmsKeys.push(props.sharedConfig.rapmAttributesTableEncryptionKey);
        }
        if (props.sharedConfig.secretsManagerEncryptionKeyARN) {
            // Give permission to secrets encryption key
            kmsKeys.push(props.sharedConfig.secretsManagerEncryptionKeyARN);
        }

        registerBlueprintLambda.addToRolePolicy(
            new PolicyStatement({
                effect: Effect.ALLOW,
                actions: ['kms:Decrypt', 'kms:List*', 'kms:DescribeKey'],
                resources: kmsKeys,
            })
        );

        artifactsBucket.grantRead(registerBlueprintLambda);

        registerBlueprintLambda.addToRolePolicy(
            PolicyStatement.fromJson({
                Effect: Effect.ALLOW,
                Action: 'execute-api:Invoke',
                Resource: 'arn:aws:execute-api:*:*:*/*/*/*',
            })
        );

        pipeline.addStage({
            stageName: 'Register',
            actions: [
                new LambdaInvokeAction({
                    actionName: 'Register_Pattern',
                    lambda: registerBlueprintLambda,
                    userParameters: {
                        VERSION_COMMIT_ID: `#{${sourceVariablesNamespace}.CommitId}`,
                        VERSION_COMMIT_MESSAGE: `#{${sourceVariablesNamespace}.CommitMessage}`,
                        BLUEPRINT_TYPE: `${props.blueprintType}`,
                        CONTROL_ARTIFACTS_LOCATION: controlArtifactsLocation,
                        CONTROL_ARTIFACTS_NAMES: buildAction.variable(
                            'CONTROL_ARTIFACTS_NAMES'
                        ),
                        IMAGE_ARTIFACTS_LOCATION: imageArtifactsLocation,
                        IMAGE_ARTIFACTS_NAMES: buildAction.variable(
                            'IMAGE_ARTIFACTS_NAMES'
                        ),
                        MARKDOWN_ARTIFACTS_LOCATION: markdownArtifactsLocation,
                        MARKDOWN_ARTIFACTS_NAMES: buildAction.variable(
                            'MARKDOWN_ARTIFACTS_NAMES'
                        ),
                        CHANGED_SERVICE_CATALOG_PRODUCTS: publishAction?.variable(
                            'CHANGED_SERVICE_CATALOG_PRODUCTS'
                        ),
                        ALL_SERVICE_CATALOG_PRODUCTS: publishAction?.variable(
                            'ALL_SERVICE_CATALOG_PRODUCTS'
                        ),
                        CHANGED_PACKAGES: releaseAction.variable('CHANGED_PACKAGES'),
                        ALL_PACKAGES: releaseAction.variable('ALL_PACKAGES'),
                    },
                }),
            ],
        });
        Aspects.of(pipeline).add(
            new CfnNagResourcePathEndingWithSuppressionAspect(
                '/Register/Register_Pattern/CodePipelineActionRole/DefaultPolicy/Resource',
                [
                    {
                        id: 'W12',
                        reason: 'Security group is created by CDK and is egress only',
                    },
                ]
            )
        );
    }

    private createPipelineArtifactBucket(
        patternId: string,
        patternType: string,
        encryptionKeyArn?: string
    ): {
        s3Bucket: Bucket;
        encryptionKey: IKey;
    } {
        // can't use the default bucket because it uses a KMS key that doesn't have rotation enabled
        // https://github.com/aws/aws-cdk/issues/9949
        const encryptionKey = encryptionKeyArn
            ? Key.fromKeyArn(this, `encryption-key-pipeline-artifact`, encryptionKeyArn)
            : new Key(this, `encryption-key-pipeline-artifact`, {
                  removalPolicy: RemovalPolicy.DESTROY,
                  enableKeyRotation: true,
              });
        // Create alias for the pipeline artifact bucket key
        new Alias(this, 'keyAlias', {
            aliasName: `PatternPublishPipeline-${patternId}-${patternType}`,
            targetKey: encryptionKey,
        });

        const pipelineArtifactAccessLoggingBucket = new Bucket(
            this,
            'PipelineArtifactsBucketAccesslog',
            {
                bucketName: PhysicalName.GENERATE_IF_NEEDED,
                encryption: BucketEncryption.S3_MANAGED,
                blockPublicAccess: new BlockPublicAccess(BlockPublicAccess.BLOCK_ALL),
                versioned: true,
                removalPolicy: RemovalPolicy.DESTROY,
                autoDeleteObjects: true,
            }
        );

        const s3Bucket = new Bucket(this, 'PipelineArtifactsBucket', {
            bucketName: PhysicalName.GENERATE_IF_NEEDED,
            encryptionKey,
            encryption: BucketEncryption.KMS,
            blockPublicAccess: new BlockPublicAccess(BlockPublicAccess.BLOCK_ALL),
            versioned: true,
            removalPolicy: RemovalPolicy.DESTROY,
            autoDeleteObjects: true,
            serverAccessLogsBucket: pipelineArtifactAccessLoggingBucket,
        });

        s3Bucket.addToResourcePolicy(
            new PolicyStatement({
                sid: 'HttpsOnly',
                resources: [`${s3Bucket.bucketArn}/*`],
                actions: ['*'],
                principals: [new AnyPrincipal()],
                effect: Effect.DENY,
                conditions: {
                    Bool: {
                        'aws:SecureTransport': 'false',
                    },
                },
            })
        );

        return { s3Bucket, encryptionKey };
    }
}
